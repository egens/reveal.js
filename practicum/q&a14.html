<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="../dist/reset.css">
	<link rel="stylesheet" href="../dist/reveal.css">
	<link rel="stylesheet" href="../dist/theme/black.css">
	<link rel="stylesheet" href="css/custom.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="../plugin/highlight/monokai.css">
</head>
<body>
<div class="reveal">
	<div class="watermark">
		<img src="images/yandex.svg" height="38"/>
		<img src="images/practicum.svg" />
	</div>

	<div class="slides">
		<section>
			<div class="container">
				<div class="col">
					<br>
					<div class="qa"><h5>Q&A14</h5></div>
				</div>
				<div class="col">
					<img src="images/photo.tiff" height="300" />
					<h5>Егор Ерохин</h5>
					наставник
				</div>
				<aside class="notes">
					Заранее зарегистрировать вебинар
					https://practicum.yandex.ru/webinar-form/java-developer/
					erohinegor

					Нужно быть залогиненым под учеткой, которая используется в практикуме. Выбрать пункт "студент". Нажать отправить.
					ЗАПИСЬ
					Привет
					Камеры
					Ждем остальных

					SOLID
					ТЗ 14


					— Начнем с разминки.
					<a href="https://leetcode.com/problems/ransom-note/description/">https://leetcode.com/problems/ransom-note/description/</a>
					<pre><code class="java" data-trim>
						class Solution {
							public boolean canConstruct(String ransomNote, String magazine) {
								if (ransomNote.length() > magazine.length()) return false;
								int[] alphabets_counter = new int[26];

								for (char c : magazine.toCharArray())
									alphabets_counter[c-'a']++;

								for (char c : ransomNote.toCharArray()){
									if (alphabets_counter[c-'a'] == 0) return false;
									alphabets_counter[c-'a']--;
								}
								return true;
							}
						}
					</code></pre>
					<br><br>
					<a href="https://leetcode.com/problems/find-the-pivot-integer/">https://leetcode.com/problems/find-the-pivot-integer/</a>
					<pre><code class="java" data-trim>
						int sum= n*(n+1)/2;
						double a= Math.sqrt(sum);
						if( a%1==0) return (int)a;
						else return -1;

						https://leetcode.com/problems/separate-the-digits-in-an-array/description/

						List<Integer> ans = new ArrayList();
						for (int i = 0; i < nums.length; i++) {
						List<Integer> temp = new ArrayList();
							do {
							temp.add(nums[i] % 10);
							nums[i] = nums[i] / 10;
							} while (nums[i] > 0);
							for (int j = temp.size() - 1; j >= 0; j--) {
							ans.add(temp.get(j));
							}
							}

							int[] ans1 = new int[ans.size()];
							for (int i = 0; i < ans.size(); i++) ans1[i] = ans.get(i);
							return ans1;
					</code></pre>
				</aside>
			</div>
		</section>
		<section>
			<h2>SOLID принципы</h2>
			<ul>
				<li>Single responsibility — единственной ответственности</li>
				<li>Open–closed — открытости/закрытости</li>
				<li>Liskov substitution — подстановки Лисков</li>
				<li>Interface segregation — разделения интерфейса</li>
				<li>Dependency inversion — инверсии зависимостей</li>
			</ul>
			<aside class="notes">
				Поставьте +- Кто слышал об акрониме?
				<br><br>
				Почему важно — это лакмусовая бумажка проверяет кругозор и дает в ответах зацепки для дальнейшего общения.
				Часто задают на собесах, я тоже в половине случаев.
				<br><br>
				Принципы проектирования и разработки приложений с использованием объектно ориентированного подхода подхода.
				<br><br>
				Пять правил, использование которых облегчает развитие и поддержку приложения.
				<br><br>
				Несмотря на то, что им много лет — их придумал в 2000 Боб Мартин, они все еще актуальны.
				<br><br>
				Их использование очень помогает при использовании популярного гибкого подхода к разработке. Agile методологий.
				<br><br>
				Назовем принципы
				---
				<br><br>
				Важно сказать, что нет четких инструкций и правил по применению этого и других принципов.
				И до сих пор ведутся дискуссии и выпускаются статьи что же они значат и как должны влиять на код.
				К таким статьям надо подходить скептично, мне кажется ни за 5 минут ни за час нельзя научиться их применять —
				важен опыт, насмотренность, изучение различных источников.
				Но мне кажется важным прислушаться к мнению экспертного сообщества — статей с критикой этих принципов
				не так уж много, обычно это по моему набросы. Также стоит сказать, что  они применимы не только к ООП
				языкам, но и на других уровнях абстракции — микросервисной или модульной архитектуры.
				<br><br>
				Остановимся дальше на каждом подробнее.
			</aside>
		</section>
		<section>
			<h2>Single responsibility</h2>
			"There should never be more than one reason for a class to change."
			<br>
			<img src="images/14/s.png" class="r-stretch">
			<aside class="notes">
				Первый, самый известный и кажется, что самый понятный принцип — единственной ответственности.
				<br><br>
				Проще пойти от плохого — как не надо делать. Красный флаг, когда класс содержит в своем интерфейсе два публичных метода и по 500 строк приватных методов, часть из которых обеспечивает работу одного публичного метода, часть другого, а часть — оба.
				<br><br>
				Это сложно неудобно читать потому что много и изменять потому что методы могут влиять друг на друга.
				<br><br>
				На собеседованиях Часто говорят "класс должен делать что-то одно".
				<br><br>
				На самом деле в первоисточнике цитата немного другая — "класс должен иметь одну причину для изменения"
				<br><br>
				Попробуйте описать, что именно делает класс. Если не получается обойтись без союза "и", его нужно декомпозировать.
				Опять же, все зависит от контекста системы — например если класс шифрует и вычисляет хеш строки, но эти действия в системе не выполняются отдельно друг от друга, то это не нарушение.
				Есть набор признаков, по которым можно предположить нарушение SRP.
				Если класс очень большой, скорее всего он нарушает SRP. Большие классы, которые много чего делают называют классами Бога.
				Если при использовании класса тем или иным образом большАя часть методов не запускаются, то он возможно нарушает SRP.
				<br><br>
				Есть и обратные примеры — метод toString() присутствует у всех объектов в Java, но далеко не всегда используется. Это сделано для удобства, все об этом знают, поэтому это не вызывает проблем.
				<br><br>
				String — и многие другие классы стандартной библиотеки нарушают этот принцип, потому что являются классами Бога.
				<br><br>
				Подходит не только для классов, но и на других уровнях. В философии Unix есть аналог — Do One Thing And Do It Well. (программы должны делать что-то одно и делать это хорошо).
			</aside>
		</section>
		<section>
			<h2>Open–closed</h2>
			Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
			<br>
			<img src="images/14/o.png" class="r-stretch">
			<aside class="notes">
				Что значит?
				Что будет если не соблюсти?
				Как добиться?
				<br><br>
				Новая функциональность должна размещаться в новых классах. Старые классы должны изменяться только при баг фиксах.
				<br><br>
				Изменение — причина ошибок. Любое изменение, даже минимальная правка условия может внести ошибку — логическую, которую сложнее найти, или синтаксическую.
				Человек переоценивает свои силы, когда думает — сейчас вот тут поправлю метод и закину в прод, ничего не случится. Рано или поздно случится.
				<br><br>
				Поэтому так важны тесты и их запуск перед каждым пушем.
			</aside>
		</section>
		<section>
			<h2>Liskov substitution</h2>
			Базовые типы должны быть заменяемы на подтипы.
			<br><br>
			Методы, которые используют ссылки на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом.
			<br>
			<img src="images/14/l.png" class="r-stretch">
			<aside class="notes">
				Принцип подстановки Барбары Лисков.
				<br><br>
				Часто отвечают, что при использовании в программе потомков вместо родителей не должна нарушаться логика приложения. Но это не совсем верно.
				<br><br>
				Метод может поддерживать работу с разными потомками, но при этом содержать условную конструкцию по типу аргумента.
				<br><br>
				Ее надо дополнять при добавлении нового типа. Такой метод нарушает принцип открытости/закрытости — его нужно изменять.
				<br><br>
				Поэтому важным в определении принципа является последняя фраза "использовать не зная об этом".
				<br><br>
				Для этого поведение потомков не должно противоречить поведению, заданному базовым классом.
				<br><br>
				То есть этот принцип больше про саму иерархию классов — ее надо разрабатывать так, чтобы в коде не нужно было разбираться с кем мы работаем — с родителем или потомком.
				<br><br>
				Не всегда логичные иерархии из окружающего мира хорошо ложатся в программные иерархии.
				Например, квадрат это прямоугольник. Но если отнаследовать квадрат от прямоугольника могут возникнуть проблемы — контракт прямоугольника предполагает методы по изменению длины и ширины независимо — если код программы будет использовать эту информацию, то он будет ломаться с квадратом.
				<br><br>
				В конкретном примере есть решение — например сделать объекты immutable. Но если это невозможно, то нужно менять иерархию — квадрат и прямоугольник к примеру должны наследоваться оn shape фигуры.
				<br><br>
				Для этого правила есть относительно строгие критерии, которым должен соответсвовать класс наследника, скину ссылку.
				https://www.baeldung.com/java-liskov-substitution-principle
			</aside>
		</section>
		<section>
			<h2>Interface segregation</h2>
			<br>
			<img src="images/14/i.png" class="r-stretch">
			<aside class="notes">
				Часто отвечают — много маленьких интерфейсов лучше чем один.
				<br><br>
				Еще один ответ — интерфейсы должны содержать логически обособленные, связанные между собой методы.
				<br><br>
				На самом деле этот принцип чуть глубже — в каноне Программные сущности не должны зависеть от методов, которые они не используют.
				<br><br>
				То есть это не про интерфейсы как часть языка программирования, а про взаимодействие объектов в целом (хотя это связано с интерфейсами).
				<br><br>
				Интерфейсы должны представлять дискретное обособленное поведение.
				<br><br>
				Этот принцип также иногда называют принципом единственной ответственности для интерфейсов.
			</aside>
		</section>
		<section>
			<h2>Dependency inversion</h2>
			Программные сущности не должны зависеть от методов, которые они не используют.
			<br>
			<img src="images/14/d.png" class="r-stretch">
			<aside class="notes">
				Проверить понятно ли тут написано?
				Модули верхнего Уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций (интерфейсов).
				<br><br>
				И вторая часть — абстракции не должны зависеть от деталей. Детали (конкретные имплементации) должны зависеть от абстракций.
				<br><br>
				Где тут инверсия — традиционно модули верхнего уровня зависят от нижнего, с DI наоборот — модули нижнего уровня зависят от интерфейсов модулей верхнего уровня.
				<br><br>
				Этот принцип помогает обеспечить низкую связность программных модулей между собой.
				<br><br>
				Я уже говорил, что хорошее приложение это не столько про работающий код в классах, сколько про то, как они взаимодействуют между собой.
				<br><br>
				Тут можно вспомнить концепцию высокой сцепленности внутри программного модуля, и низкой связности взаимодействия между модулями.
				<br><br>
				Разработка через интерфейсы и использование инверсии зависимостей ведет к тому, что разработчик больше задумывается об интерфейсах и о взаимодействии классов между собой, что положительно сказывается на архитектуре приложения.
				<br><br>
				Применение этого принципа облегчает тестирование, хотя современные методы тестирования позволяют использовать болванки и вместо конкретных классов.
			</aside>
		</section>
		<section>
			<h2>ФП14 ShareIt controllers</h2>
			<ul>
				<li>Ветка add-controllers</li>
				<li>User, Item, Booking, ItemRequest</li>
				<li>Пишем контроллеры</li>
				<li>Тесты в Postman</li>
			</ul>
			<aside class="notes">
				Пользователи User делятся вещами Item. Могут бронировать их на определенные даты Booking.
				И оставлять запросы, если таких вещей нет ItemRequest.
				TODO Sprint add-controllers.
				Как обычно руководствуемся тестами.
			</aside>
		</section>
		<section>
			<h2>Ваши вопросы</h2>
			<ul>
				<li>Single responsibility</li>
				<li>Open–closed</li>
				<li>Liskov substitution</li>
				<li>Interface segregation</li>
				<li>Dependency inversion</li>
				<li>ТЗ14</li>
			</ul>
		</section>
	</div>
</div>

<script src="../dist/reveal.js"></script>
<script src="../plugin/notes/notes.js"></script>
<script src="../plugin/markdown/markdown.js"></script>
<script src="../plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
