<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="../dist/reset.css">
	<link rel="stylesheet" href="../dist/reveal.css">
	<link rel="stylesheet" href="../dist/theme/black.css">
	<link rel="stylesheet" href="css/custom.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="../plugin/highlight/monokai.css">
</head>
<body>
<div class="reveal">
	<div class="watermark">
		<img src="images/yandex.svg" height="38"/>
		<img src="images/practicum.svg" />
	</div>

	<div class="slides">
		<section>
			<div class="container">
				<div class="col">
					<br>
					<div class="qa"><h1>Q&A10</h1></div>
				</div>
				<div class="col">
					<img src="images/photo.tiff" height="300" />
					<h5>Егор Ерохин</h5>
					наставник
				</div>
				<aside class="notes">
					<a href="https://practicum.yandex.ru/webinar-form/java-developer/">Заранее зарегистрировать вебинар</a>
					(erohinegor)
					<br><br>
					Нужно быть залогиненым под учеткой, которая используется в практикуме. Выбрать пункт "студент". Нажать отправить.
					<br><br>
					Поставить на запись
					<br><br>
					Привет Камеры Ждем остальных
					<br><br>
				</aside>
			</div>
		</section>
		<section>
			<h2>Спринт 10</h2>
			<ul>
				<li>Maven</li>
				<li>slf4j</li>
				<li>Аннотации</li>
				<li>Lombok</li>
				<li>REST и Spring Boot</li>
			</ul>
			<aside class="notes">
				Поздравляю, вы написали первое API на Spring. Конкретно эта работа сейчас очень востребована на рынке труда.<br>
				Сегодня поговорим про системы сборки, Spring, месте логирования в текущем мире разработки.<br>
				Обсудим Lombok и альтернативу наследованию — композицию.<br>
				Обсудим ФП9<br>
				Отвечу на вопросы по хард вебинару
				<br><br>
				<a href="https://leetcode.com/problems/count-common-words-with-one-occurrence/">https://leetcode.com/problems/count-common-words-with-one-occurrence/</a>
				<pre><code class="java" data-trim>
							<script type="text/template">
								class Solution {
									public int maxPower(String s) {
										int c = 1, res = 1;
										for (int i = 0; i < s.length() - 1; i++) {
											if (s.charAt(i) == s.charAt(i + 1)) {
												c++;
											} else {
												c = 1;
											}
											res = Math.max(res, c);
										}
										return res;
									}
								}
							</script>
						</code></pre>
				<a href="https://leetcode.com/problems/climbing-stairs/description/">https://leetcode.com/problems/climbing-stairs/description/</a>
				<pre><code class="java" data-trim>
						class Solution {
							// 1 - 1
							// 2 - 2
							public int climbStairs(int n) {
								if (n == 1) return 1;
								int[] dp = new int[n];
								dp[0] = 1;
								dp[1] = 2;
								for (int i = 2; i < n; i++) {
									dp[i] = dp[i - 1] + dp[i - 2];
								}
								return dp[n - 1];
							}
						}
						</code></pre>
			</aside>
		</section>
		<section>
			<h2>Системы сборки, Maven</h2>
			<ul>
				<li>Создание Maven проекта</li>
				<li>Основные блоки XML</li>
				<li>Подключение зависимостей</li>
				<li>Репозитории</li>
				<li>Процесс сборки</li>
			</ul>
			<aside class="notes">
				Вы познакомились с системой сборки Maven. Maven с gradle покрывают большинство проектов.
				Я лично использую gradle. Потому что у меня паталогическая неприязнь к XML.
				С системой сборки разработчик много взаимодействует при первоначальной настройке проекта, а дальше в нее вносятся изменения гораздо реже по мере необходимости.

				Какие типы репозиториев? Локальный, удаленный, центальный

				Чаще всего будете работать с удаленными репозиториями, внутри компании — для требований безопасности и использования других артефактов. Они проксируют центральный.

				Разрешение конфликтов часто используется при работе нескольких человек над кодовой базой.
				При мердже или MR в мастер ветку лучше сначала пуллить удаленные изменения, чтобы осуществить мердж локально. Часто сервер VCS не может разрулить мердж и просит сделать это вручную.
			</aside>
		</section>
		<section>
			<h2>Логирование</h2>
			<ul>
				<li>SLF4J</li>
				<li>Elasticsearch, Logstash, and Kibana</li>
				<li>Opensearch</li>
				<li>Prometheus, Grafana</li>
			</ul>
			<aside class="notes">
				Вы научились писать логи правильным способом.

				Вкратце покажу, что с ними происходит дальше.
				Сервисы пишут в консоль, сборщик отправляет их в хранилище.

				Обычно это ELK, Opensearch. Prometheus+grafana иногда используют, но чаще для мониторинга метрик работы приложения — например, загруженности CPU на серверах.

				Сервисы позволяют рисовать дашборды, а также имеют интерфейс для текстового поиска и анализа логов.
				Часто там довольно много всего лежит, поэтому время хранения ограничено неделей-месяцем.
				Если какую-то информацию о работе нужно хранить дольше, это делают программно через БД.

				У нас даже есть отдельное API для фронта, куда он шлет свои ошибки, чтобы они также логгировались централизовано.
			</aside>
		</section>
		<section>
			<h2>Lombok</h2>
			<ul>
				<img src="images/10/lombok.jpg"/>
			</ul>
			<aside class="notes">
				Теперь немного отдохнем. Фото одноименного острова в Индонезии для тех, кто не гуглил.
				Ну как вам кодогенерация? Поставьте + кто устал уже писать бойлерплейт код.
				Кодогенерация действительно сильно облегчает жизнь, но с ней надо быть оккуратнее.
				Из последнего — вынес часть логики в отдельный пакет и из-за того, что Builder генерирует package-private конструктор, не смог использовать его при подключении зависимости. Разбирался.
			</aside>
		</section>
		<section>
			<h2>REST и Spring boot</h2>
			<ul>
				<li>Spring Framework для Java приложений</li>
				<li>Inversion of control (IoC)</li>
				<li>Dependency injection (DI)</li>
				<li>REST архитектура для API</li>
			</ul>
			<aside class="notes">
				Спринг построен на двух столпах — принципах внедрении зависимостей и инверсии контроля.
				Что это означает на пальцах? Раньше вы писали набор классов, определяли их создание, взаимодействие, передачу из одного места в другое. И этим обеспечивая работу приложения.
				При работе со спрингом у вас есть корзина с бинами — объектами классов. Это — контекст приложения.
				Каждый Бин задает свои зависимости — какие сервисы ему нужны для работы.
				И Спринг магическим образом автоматически разруливает и связывает их между собой.

				Теперь не вы управляете потоком выполнения, Спринг фреймворк вызывает ваш код, это по сути и есть IoC или инверсия управления.
				Обратите внимание, вы не писали запуск-остановку сервера, у вас не было почти никакой логики в методе main и все отлично работало.
				Внедрение зависимостей в контексте спринга — передача классов-зависимостей в аргументах конструктора. Таким образом мы отвязываем наш класс от создания его зависимостей, обеспечивая низкую связность.
				Спринг позволяет писать код с низкой связностью компонентов и простым тестированием.
				REST я давал на прошлом вебинаре и в лекциях было. Это набор правил для создания клиент-серверной архитектуры.
				Что такое идемпотентность и безопасность? Кто расскажет. Какие методы HTTP?
			</aside>
		</section>
		<section>
			<h2>Наследование</h2>
			<ul>
				<li>Делает классы сильно связными</li>
				<li>"Нарушает" инкапсуляцию</li>
				<li>Усложняет изменения</li>
			</ul>
			<br><br>
			<h2>Композиция</h2>
			<ul>
				<li>Не связывает классы друг с другом</li>
				<li>Изменяема после компиляции</li>
				<li>Упрощает тестирование</li>
			</ul>
			<aside class="notes">
				https://softwareengineering.stackexchange.com/a/371715

				Хочу поговорить с вами про композицию.
				<br>
				Композиция по простому это наличие одного класса как поля в другом.
				<br>
				То есть если наследование это отношение "является", то композиция — "состоит из".
				<br>
				Наследование делает классы сильно связными, поведение потомка можно сломать, изменив поведение родителя,
				тестировать их нужно вместе. Чтобы понять, как работает потомок, нужно разобраться в коде родителя.
				<br>
				Нарушает инкапсуляцию в смысле того, что классу потомку доступны "кишки" родителя — вот так вот один
				принцип ООП противоречит другому. :)
				<br>
				Затрудняет изменения в кодовой базе — если вы привязали двух потомков к одному предку и вам понадобилось
				изменить логику работы только одного из них, вам придется их отвязывать.
				<br>
				При композиции вы сами регулируете насколько связаны между собой классы — делает интерфейс с теми методами,
				которые нужны классу и создаете поле интерфейсного типа.
				<br>
				Зависимости становятся полями класса, понятно, что в процессе выполнения их можно заменить на другие реализации.
				Иерархия после компиляции неизменяема.
				<br>
				С помощью композиции просто организовать тестирование — дайте вместо зависимостей заглушки, сэмулируйте
				их работу и спокойно проверяйте работу класса в изоляции.
				<br>
				Если вы хотите использовать наследования только чтобы переиспользовать код, скорее всего вам лучше применить композицию.
				<br>
				В исходниках Java полно наследования — но Java писалась давно, с тех пор техники разработки поменялись,
				но центральные компоненты больно переписывать.
				<br>
				Есть такая проблема Stack Vector в java. Если вы посмотрите исходники Stack наследуется от Vector, а так
				как и вектор является конкретным классом, то в стэк попадает куча методов, которые традиционно отходят
				от логики стека — например, случайный доступ к элементу, поиск и другие.
			</aside>
		</section>
		<section>
			<h2>ФП10 Filmorate начало</h2>
			<ul>
				<li>Как сдавать?</li>
				<li>Шаблон с JDK 11 в Группе</li>
				<li>Модели Film, User</li>
				<li>Контроллеры для моделей</li>
				<li>Валидация</li>
				<li>Логгирование</li>
				<li>Тесты валидации</li>
			</ul>
			<aside class="notes">
				Как сдавать? Сделать ветку и pull request с кодом. Запустятся автопроверки. Строго соблюдать название ветки.
				<br>
				Мержить не надо, если что-то правим — пушим в эту же ветку. Когда ревьюер дал добро — мержим.
				<br>
				Важно, что все проекты в курсе делаем на 21 JDK. На это завязаны авто проверки в том числе.
				<br>
				Spring initializr не поддерживает 11 java
				<br>
				DELOMBOK показать
			</aside>
		</section>
		<section>
			<h2>Ваши вопросы</h2>
			<ul>
				<li>Спринт 10</li>
				<li>Системы сборки, Maven</li>
				<li>Логирование</li>
				<li>Lombok</li>
				<li>REST и Spring boot</li>
				<li>Наследование</li>
				<li>Композиция</li>
				<li>ФП10 Filmorate начало</li>
			</ul>
		</section>
	</div>
</div>

<script src="../dist/reveal.js"></script>
<script src="../plugin/notes/notes.js"></script>
<script src="../plugin/markdown/markdown.js"></script>
<script src="../plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
