<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="../dist/reset.css">
	<link rel="stylesheet" href="../dist/reveal.css">
	<link rel="stylesheet" href="../dist/theme/black.css">
	<link rel="stylesheet" href="css/custom.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="../plugin/highlight/monokai.css">
</head>
<body>
<div class="reveal">
	<div class="watermark">
		<img src="images/yandex.svg" height="38"/>
		<img src="images/practicum.svg" />
	</div>

	<div class="slides">
		<section>
			<div class="container">
				<div class="col">
					<br>
					<div class="qa"><h1>Q&A10</h1></div>
				</div>
				<div class="col">
					<img src="images/photo.tiff" height="300" />
					<h5>Егор Ерохин</h5>
					наставник
				</div>
				<aside class="notes">
					<a href="https://practicum.yandex.ru/webinar-form/java-developer/">Заранее зарегистрировать вебинар</a>
					(erohinegor)
					<br><br>
					Нужно быть залогиненым под учеткой, которая используется в практикуме. Выбрать пункт "студент". Нажать отправить.
					<br><br>
					Поставить на запись
					<br><br>
					Привет Камеры Ждем остальных
					<br><br>
					<a href="https://leetcode.com/problems/roman-to-integer/">https://leetcode.com/problems/roman-to-integer/</a>
					<pre><code class="java" data-trim>
							<script type="text/template">
								class Solution {
								public int romanToInt(String s) {
									Map<Character, Integer> m = new HashMap<>();

									m.put('I', 1);
									m.put('V', 5);
									m.put('X', 10);
									m.put('L', 50);
									m.put('C', 100);
									m.put('D', 500);
									m.put('M', 1000);

									int ans = 0;

									for (int i = 0; i < s.length(); i++) {
										if (i < s.length() - 1 && m.get(s.charAt(i)) < m.get(s.charAt(i + 1))) {
											ans -= m.get(s.charAt(i));
										} else {
											ans += m.get(s.charAt(i));
										}
									}

									return ans;
								}
							}
							</script>
						</code></pre>
					<br><br>
					<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">https://leetcode.com/problems/maximum-depth-of-binary-tree/description/</a>
					<pre><code class="java" data-trim>
							<script type="text/template">
								class Solution {
								public int maxDepth(TreeNode root) {
								if (root == null) return 0;
								return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
								}
								}
							</script>
						</code></pre>
					<br><br>
					<a href="https://leetcode.com/problems/count-common-words-with-one-occurrence/">https://leetcode.com/problems/count-common-words-with-one-occurrence/</a>
					<pre><code class="java" data-trim>
							<script type="text/template">
								class Solution {
								public int maxPower(String s) {
								int c = 1, res = 1;
								for (int i = 0; i < s.length() - 1; i++) {
								if (s.charAt(i) == s.charAt(i + 1)) {
								c++;
								} else {
								c = 1;
								}
								res = Math.max(res, c);
								}
								return res;
								}
								}
							</script>
						</code></pre>
					<br><br>
					<a href="https://leetcode.com/problems/climbing-stairs/description/">https://leetcode.com/problems/climbing-stairs/description/</a>
					<pre><code class="java" data-trim>
						class Solution {
							// 1 - 1
							// 2 - 2
							public int climbStairs(int n) {
								if (n == 1) return 1;
								int[] dp = new int[n];
								dp[0] = 1;
								dp[1] = 2;
								for (int i = 2; i < n; i++) {
									dp[i] = dp[i - 1] + dp[i - 2];
								}
								return dp[n - 1];
							}
						}
						</code></pre>
				</aside>
			</div>
		</section>
		<section>
			<h2>Спринт 10</h2>
			<ul>
				<li>Maven</li>
				<li>slf4j</li>
				<li>Аннотации</li>
				<li>Lombok</li>
				<li>REST и Spring Boot</li>
			</ul>
			<aside class="notes">
				Мы переходим к написанию API на Spring. Конкретно эта работа сейчас очень востребована на рынке труда.
				<br>
				Сегодня поговорим про системы сборки, месте логирования в текущем мире разработки, Spring.
				<br>
				Обсудим Lombok и альтернативу наследованию — композицию.
				<br>
				Обсудим ФП10
				<br>
				Отвечу на вопросы по хард вебинару
			</aside>
		</section>
		<section>
			<h2>Системы сборки</h2>
			<ul>
				<li>Maven, gradle, ant</li>
				<li>Типы репозиториев</li>
				<li>Многомодульные проекты</li>
			</ul>
			<aside class="notes">
				Вы познакомились с системой сборки Maven. Maven с gradle покрывают большинство проектов.
				<br>
				Здесь и далее в курсе мы будем использовать Maven.
				<br>
				Я лично использую gradle. Потому что у меня паталогическая неприязнь к XML.
				<br>
				С системой сборки разработчик много взаимодействует при первоначальной настройке проекта, а дальше в нее вносятся изменения гораздо реже по мере необходимости.
				<br><br>
				Какие типы репозиториев? Локальный, удаленный, центральный
				<br><br>
				Чаще всего будете работать с удаленными репозиториями, внутри компании — для требований безопасности и использования других артефактов. Они проксируют центральный.
			</aside>
		</section>
		<section>
			<h2>Логирование</h2>
			<ul>
				<li>SLF4J</li>
				<li>Elasticsearch, Logstash, and Kibana</li>
				<li>Opensearch</li>
				<li>Prometheus, Grafana</li>
			</ul>
			<aside class="notes">
				Вы научились писать логи правильным способом. SLF4j — самый распространенный фреймворк и я тоже его использую.
				<br><br>
				Вкратце покажу, что с ними происходит дальше.
				<br>
				Сервисы пишут в консоль, сборщик отправляет их в хранилище.
				<br><br>
				Обычно это ELK, Opensearch. Prometheus+grafana иногда используют, но чаще для мониторинга метрик работы приложения — например, загруженности CPU на серверах.
				<br><br>
				Сервисы позволяют рисовать дашборды, а также имеют интерфейс для текстового поиска и анализа логов.
				<br>
				Часто там довольно много всего лежит, поэтому время хранения ограничено неделей-месяцем.
				<br>
				Если какую-то информацию о работе нужно хранить дольше, это делают программно через БД.
				<br>
				У нас даже есть отдельное API для фронта, куда он шлет свои ошибки, чтобы они также логировались централизовано.
			</aside>
		</section>
		<section>
			<h2>Аннотации</h2>
			<ul>
				<li>Метаданные для кода</li>
				<li>@Override, @Deprecated, @SuppressWarnings</li>
				<li>Рефлексия</li>
			</ul>
			<aside class="notes">
				Аннотации — это специальные метаданные, которые можно добавлять к коду для описания его поведения. Они помогают компилятору, среде выполнения и разработчикам.
				<br><br>
				В Java есть несколько встроенных аннотаций. Самые популярные:
				<br>
				@Override — помечает метод, который предполагается переопределить из родительского класса;
				<br>
				@Deprecated — указывает, что элемент программы устарел и может быть удалён в будущих версиях;
				<br>
				@SuppressWarnings — позволяет подавить предупреждения компилятора.
				<br><br>
				Аннотации используются для автоматизации различных аспектов программирования, таких как конфигурация
				<br>
				фреймворков (Spring, Hibernate), написание тестов (JUnit), валидация данных и работа с ORM. Они помогают
				<br>
				минимизировать количество шаблонного кода и делают код более чистым и поддерживаемым.
				<br><br>
				Рефлексия — механизм, позволяющий программе анализировать и модифицировать свою структуру во время выполнения.
				<br>
				В Java рефлексия происходит с помощью специального набора классов и интерфейсов — Reflection API.
				<br><br>
				Аннотации, как и рефлексия довольно специфические инструменты. Они увеличивают когнитивную сложность кода и часто можно обойтись без них.
				<br>
				Но они часто используются при написании фреймворков — внутри Spring полно рефлексии и он предоставляет набор часто используемых аннотаций.
				<br>
				Вам сейчас рассказали об этих инструментах, не чтобы вы начали их применять, а скорее, чтобы Спринг не казался излишней магией.
				<br>
				Самому лучше десять раз подумать, прежде чем использовать их.
			</aside>
		</section>
		<section>
			<h2>Lombok</h2>
			<ul>
				<img src="images/10/lombok.jpg"/>
			</ul>
			<aside class="notes">
				Теперь немного отдохнем. Фото одноименного острова в Индонезии для тех, кто не гуглил.
				<br>
				Ну как вам кодогенерация? Поставьте + кто устал уже писать бойлерплейт код.
				<br>
				Кодогенерация действительно сильно облегчает жизнь, но с ней надо быть аккуратнее.
				<br>
				Из последнего — вынес часть логики в отдельный пакет и из-за того, что Builder генерирует
				package-private конструктор, не смог использовать его при подключении зависимости. Разбирался.
			</aside>
		</section>
		<section>
			<h2>Spring boot</h2>
			<ul>
				<li>Spring Framework для Java приложений</li>
				<li>Inversion of control (IoC)</li>
				<li>Dependency injection (DI)</li>
				<li>REST архитектура для API</li>
			</ul>
			<aside class="notes">
				Спринг построен на двух столпах — принципах внедрении зависимостей и инверсии контроля.
				<br>
				Что это означает на пальцах? Раньше вы писали набор классов, определяли их создание, взаимодействие, передачу из одного места в другое. И этим обеспечивая работу приложения.
				<br>
				При работе со спрингом у вас есть корзина с бинами — объектами классов. Это — контекст приложения.
				<br>
				Каждый Бин задает свои зависимости — какие сервисы ему нужны для работы.
				<br>
				И Спринг магическим образом автоматически разруливает и связывает их между собой.
				<br><br>
				Теперь не вы управляете потоком выполнения, Спринг фреймворк вызывает ваш код, это по сути и есть IoC или инверсия управления.
				<br>
				Обратите внимание, вы не писали запуск-остановку сервера, у вас не было почти никакой логики в методе main и все отлично работало.
				<br>
				Внедрение зависимостей в контексте спринга — передача классов-зависимостей в аргументах конструктора. Таким образом мы отвязываем наш класс от создания его зависимостей, обеспечивая низкую связность.
				<br>
				Спринг позволяет писать код с низкой связностью компонентов и простым тестированием.
				<br>
				REST я давал на прошлом вебинаре и в лекциях было. Это набор правил для создания клиент-серверной архитектуры.
				<br>
				Что такое идемпотентность и безопасность? Кто расскажет. Какие методы HTTP?
			</aside>
		</section>
		<section>
			<h2>REST</h2>
			<ul>
				<li>Representational state transfer</li>
				<li>Архитектурный стиль</li>
				<li>Веб-страница — представление ресурса</li>
				<li>Ресурсы скрыты за url: /tasks, /tasks/{id}/subtasks, /tasks?priority=10</li>
				<li>Часто называют любой HTTP API, хотя они нарушают Stateless или HATEOAS</li>
			</ul>
			<aside class="notes">
				Что такое REST кто слышал до хард вебинара + ?
				<br>
				Передача репрезентативного состояния. Первое упоминание в диссертации Роя Филдинга в 2000г.
				<br>
				Архитектурный стиль описывающий взаимодействие физически разделенных компонент, например по сети интернет в клиент-серверной архитектуре.
				<br><br>
				Согласно REST за каждым url web api скрывается ресурс, действия с которым описываются различными методами HTTP. А веб-страница является пользовательским представлением ресурса или нескольких ресурсов.
				<br>
				Ресурсы скрыты за URL, нет единого подхода к формированию — что размещать в path, query params и body запроса.
				<br>
				Но чаще я встречал, что ресурс — существительное во множественном числе, в path содержатся идентификаторы элементов, поддерживается вложенность ресурсов, в query params добавляются фильтры ресурса, а в body передаются данные. Методы HTTP — глаголы, описывающие действия над ресурсом.
				<br>
				Из-за отсутствия строгих формулировок часто нарушается в некоторых моментах. Например stateless, то есть сервер не должен использовать информацию от предыдущих запросов пользователя.
				<br>
				HATEOAS — ответ ресурса должен содержать гиперссылки на возможные действия с этим ресурсом. Это практически никогда не выполняется.
				<br><br>
				Что такое идемпотентность и безопасность? Кто расскажет. Какие методы HTTP?
			</aside>
		</section>
		<section>
			<h2>Наследование</h2>
			<ul>
				<li>Делает классы сильно связными</li>
				<li>"Нарушает" инкапсуляцию</li>
				<li>Усложняет изменения</li>
			</ul>
			<br><br>
			<h2>Композиция</h2>
			<ul>
				<li>Не связывает классы друг с другом</li>
				<li>Изменяема после компиляции</li>
				<li>Упрощает тестирование</li>
			</ul>
			<aside class="notes">
				https://softwareengineering.stackexchange.com/a/371715
				<br>
				Хочу поговорить с вами про композицию.
				<br>
				Композиция по простому это наличие одного класса как поля в другом.
				<br>
				То есть если наследование это отношение "является", то композиция — "состоит из".
				<br>
				Наследование делает классы сильно связными, поведение потомка можно сломать, изменив поведение родителя,
				тестировать их нужно вместе. Чтобы понять, как работает потомок, нужно разобраться в коде родителя.
				<br>
				Нарушает инкапсуляцию в смысле того, что классу потомку доступны "кишки" родителя — вот так вот один
				принцип ООП противоречит другому. :)
				<br>
				Затрудняет изменения в кодовой базе — если вы привязали двух потомков к одному предку и вам понадобилось
				изменить логику работы только одного из них, вам придется их отвязывать.
				<br><br>
				При композиции вы сами регулируете насколько связаны между собой классы — делает интерфейс с теми методами,
				которые нужны классу и создаете поле интерфейсного типа.
				<br>
				Зависимости становятся полями класса, понятно, что в процессе выполнения их можно заменить на другие реализации.
				Иерархия после компиляции неизменяема.
				<br>
				С помощью композиции просто организовать тестирование — дайте вместо зависимостей заглушки, сэмулируйте
				их работу и спокойно проверяйте работу класса в изоляции.
				<br>
				Если вы хотите использовать наследования только чтобы переиспользовать код, скорее всего вам лучше применить композицию.
				<br>
				В исходниках Java полно наследования — но Java писалась давно, с тех пор техники разработки поменялись,
				но центральные компоненты больно переписывать.
				<br>
				Есть такая проблема Stack Vector в java. Если вы посмотрите исходники Stack наследуется от Vector, а так
				как и вектор является конкретным классом, то в стэк попадает куча методов, которые традиционно отходят
				sот логики стека — например, случайный доступ к элементу, поиск и другие.
			</aside>
		</section>
		<section>
			<h2>ФП10 Filmorate начало</h2>
			<ul>
				<li>Как сдавать?</li>
				<li>Модели Film, User</li>
				<li>Контроллеры для моделей</li>
				<li>Валидация</li>
				<li>Логирование</li>
				<li>Тесты валидации</li>
			</ul>
			<aside class="notes">
				У вас в github должен появиться репозиторий java-filmorate работаем в нем.
				<br>
				Вам нужно написать модели Фильм, Пользователь, Добавить эндпоинты для них, валидацию и логирование.
				<br>
				Валидацию даты фильма можно реализовать отдельным методом и сделать тесты на него.
				Написание аннотации валидации и тестирование через валидатор — задача со звездочкой.
				<br>
				Как сдавать? Сделать ветку и pull request с кодом. Запустятся автопроверки. Строго соблюдать название ветки.
				<br>
				Мержить не надо, если что-то правим — пушим в эту же ветку. Когда ревьюер дал добро — мержим.
				<br>
				Важно, что все проекты в курсе делаем на 21 JDK. На это завязаны авто проверки в том числе.
				<br>
				DELOMBOK показать
			</aside>
		</section>
		<section>
			<h2>Спринт 10 — Ваши вопросы</h2>
			<ul>
				<li>Системы сборки, Maven</li>
				<li>Логирование</li>
				<li>Аннотации</li>
				<li>Lombok</li>
				<li>REST и Spring boot</li>
				<li>Наследование</li>
				<li>Композиция</li>
				<li>ФП10 Filmorate начало</li>
			</ul>
		</section>
	</div>
</div>

<script src="../dist/reveal.js"></script>
<script src="../plugin/notes/notes.js"></script>
<script src="../plugin/markdown/markdown.js"></script>
<script src="../plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
