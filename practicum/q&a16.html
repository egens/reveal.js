<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/black.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="watermark">
				<img src="images/yandex.svg" height="38"/>
				<img src="images/practicum.svg" />
			</div>

			<div class="slides">
				<section>
					<div class="container">
						<div class="col">
							<br>
							<div class="qa"><h1>Q&A16</h1></div>
						</div>
						<div class="col">
							<img src="images/photo.tiff" height="300" />
							<h5>Егор Ерохин</h5>
							наставник
						</div>
						<aside class="notes">
							<a href="https://practicum.yandex.ru/webinar-form/java-developer/">Заранее зарегистрировать вебинар</a>
							(erohinegor)
							<br><br>
							Нужно быть залогиненым под учеткой, которая используется в практикуме. Выбрать пункт "студент". Нажать отправить.
							<br><br>
							Поставить на запись
							<br><br>
							Привет Камеры Ждем остальных
							<br><br>
						</aside>
					</div>
				</section>
				<section>
					<h2>Спринт 16</h2>
					<ul>
						<li>Микросервисы</li>
						<li>Типы взаимодействия</li>
						<li>Docker (hub, compose)</li>
						<li>Работа на сервере</li>
					</ul>
					<aside class="notes">
						Рассмотрим некоторые паттерны микросервисов<br>
						Обсудим особенности синхронного и асинхронного взаимодействия<br>
						Разберем, как устроен Docker compose файл<br>
						Еще раз проговорим аргументы за терминал
						<br><br>
						<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">https://leetcode.com/problems/binary-tree-inorder-traversal/</a>
						Центрированный обход — сначала левая часть дерева, потом текущий узел, потом правая
						<pre><code class="java" data-trim>
							<script type="text/template">
								class Solution {
									public List<Integer> inorderTraversal(TreeNode root) {
										List<Integer> res = new ArrayList<>();
										inorder(root, res);
										return res;
									}

									public void inorder(TreeNode n, List<Integer> res) {
										if (n == null) return;
											inorder(n.left, res);
											res.add(n.val);
											inorder(n.right, res);
									}
								}
							</script>
						</code></pre>
						<a href="https://leetcode.com/problems/climbing-stairs/description/">https://leetcode.com/problems/climbing-stairs/description/</a>
						<pre><code class="java" data-trim>
						class Solution {
							// 1 - 1
							// 2 - 2
							public int climbStairs(int n) {
								if (n == 1) return 1;
								int[] dp = new int[n];
								dp[0] = 1;
								dp[1] = 2;
								for (int i = 2; i < n; i++) {
									dp[i] = dp[i - 1] + dp[i - 2];
								}
								return dp[n - 1];
							}
						}
						</code></pre>
					</aside>
				</section>
				<section>
					<h2>Микросервисы помогают</h2>
					<ul>
						<li>Добавлять новую функциональность</li>
						<li>Использовать разные технологии</li>
						<li>Переиспользовать код</li>
						<li>Масштабировать часть приложения</li>
						<li>Распределять задачи разработки</li>
					</ul>
					<aside class="notes">
						Как вы поняли, что такое микросервисы? (голосом или напечатать, обсудить)
						<br><br>
						Это архитектура, при которой бизнес логика разделяется между небольшими приложениями.
						<br><br>
						Чем микросервисы лучше монолита? (ответ из теории)
						<br><br>
						Их можно тестировать и развёртывать по отдельности.
						Это упрощает внесение изменений и добавление новой функциональности.
						<br><br>
						Микросервисы — это автономные компоненты, поэтому внутри одного приложения можно использовать
						разные фреймворки и даже языки программирования.
						<br><br>
						Небольшие сервисы можно переиспользовать другим командам — они реализуют конкретную функциональность,
						которую можно использовать в другом месте.
						<br><br>
						Можно масштабировать отдельную часть приложения, если какая-то функциональность сильно нагружена.
						<br><br>
						Микросервис проще изолировать от остального приложения и поручить отдельному разработчику.
						Следовательно, одновременно над одним кодом работает меньше человек, чем в случае с монолитом.
					</aside>
				</section>
<!-- Паттерны микросервисов это круто, но кажется, что лишнее на данном этапе -->
<!-- Пробую без них -->
<!--					<section>-->
<!--						<h2>Паттерны микросервисов</h2>-->
<!--						<ul>-->
<!--							<li>API Gateway</li>-->
<!--							<li>Service Registry/Discovery</li>-->
<!--							<li>Circuit Breaker</li>-->
<!--							<li>Event Sourcing</li>-->
<!--							<li>Strangler</li>-->
<!--						</ul>-->
<!--						<aside class="notes">-->
<!--							API Gateway: Этот паттерн предусматривает создание единой точки входа (API Gateway) для всех клиентских запросов. API Gateway принимает запросы, маршрутизирует их к соответствующим микросервисам и выполняет агрегацию данных при необходимости. Это позволяет упростить клиентскую логику, обеспечить единую точку управления и повысить безопасность системы.-->
<!--							<br><br>-->
<!--							Service Registry и Service Discovery: В микросервисной архитектуре, где сервисы могут динамически масштабироваться и развертываться, необходимо иметь механизмы для регистрации сервисов и их обнаружения. Service Registry представляет собой централизованный реестр, в котором сервисы регистрируют себя и свои адреса. Service Discovery позволяет клиентским сервисам динамически находить и взаимодействовать с другими сервисами.-->
<!--							<br><br>-->
<!--							Circuit Breaker: Этот паттерн предназначен для обработки сбоев во взаимодействии между микросервисами. Он предполагает использование специального компонента (Circuit Breaker), который отслеживает состояние и доступность сервисов. Если сервис становится недоступным или отвечает с ошибками, Circuit Breaker переключается в режим отказа и предотвращает дальнейшие неудачные запросы. Это позволяет предотвратить каскадные сбои и улучшить отказоустойчивость системы.-->
<!--							<br><br>-->
<!--							Паттерн Event Sourcing: Этот паттерн предлагает сохранять все изменения состояния системы в виде событий (events). Вместо сохранения текущего состояния, каждое действие, приводящее к изменению состояния, сохраняется как событие в журнале событий. Это позволяет восстановить состояние системы на любой момент времени и обеспечить аудит и отслеживаемость изменений.-->
<!--							<br><br>-->
<!--							Strangler: Если вы работаете в организации, которая находится на пути к модернизации приложений, то часто применяют шаблон проектирования Strangler. Паттерн Strangler выступает за создание надстройки фасада поверх вашего легаси и нового приложения. Функциональность API выносится из монолита постепенно. Монолит при этом каждую итерацию уменьшается в размере.-->
<!--						</aside>-->
<!--					</section>-->
				<section>
					<h2>Синхронное — асинхронное</h2>
					<img src="images/16/syncasync.tiff" height="400px">
					<img src="images/16/meme.tiff"height="400px">
					<aside class="notes">
						Кто расскажет чем отличается синхронное и асинхронное взаимодействие? (голосом или напечатать, обсудить)
						<br><br>
						При синхронном мы отправляем запрос и ждем ответа. При асинхронном кидаем в черный ящик запрос и продолжаем работу.
						Если нужен ответ — слушаем черный ящик.
						<br><br>

						Давайте рассмотрим синхронное — web и rest api.<br>
						Отправляем запрос в другой сервис, ждем и получаем ответ. Легче для реализации.<br>
						При этом раньше программа блокировалась, когда ждет ответ. Но сейчас есть неблокирующие реализации.<br>
						Балансировка при синхронном взаимодействии требует участия третьей стороны.<br>
						Часто для этого используют nginx, в Kubernetes это вообще скрывается от разработчика.<br>
						Но накладные расходы на балансировку остаются.<br>
						Доступно кэширование — например, при одинаковых запросах получение данных можно не выполнять логику,<br>
						а возвращать в течении определенного времени последний результат.<br>
						Отладка довольное сложная. Часто действия выглядят, как последовательные вызовы нескольких микросервисов.<br>
						Чтобы изучить проблему, нужно вытащить всю цепочку вызовов. Эта техника называется трейсинг.<br>
						Важный аспект — задать поведение при таймаутах. Потому что не все запросы могут выполниться.<br>
						Также, в HTTP часто в разных местах сети есть таймауты 60 сек, поэтому если запросы долгие, нужно перейти на асинхронное.<br>
						Строгого правила нет, но по моему опыту — до 1 сек хорошо, до 10 сек приемлемо, до 60 секунд на грани.<br>
						<br>

						Теперь рассмотрим асинхронное — шина обмена данными, например Kafka или rabbitmq.<br>
						Кидаем сообщение в шину, если надо слушаем очередь ответов.<br>
						Ниже связность между компонентами — каждый знает только про шину и ничего не знает о том, как происходит обработка.<br>
						Отладка проще — не нужно трассировать запросы, у каждого сервиса есть вход и выход.<br>
						Позволяет обработать сообщения заново, если что-то пошло не так — часто они сохраняются на шине.<br>
						Проще скейлить — ставишь столько обработчиков, сколько нужно.<br>
						Можно отправлять сообщение на обработку разными сервисами — они читают одну очередь независимо.<br>
						Брокер сообщений становится внешней зависимостью и единой точкой отказа.
						<br><br>
						Важное про RestTemplate — еще несколько лет назад все рекомендовали переходить на WebClient.
						Это новая неблокирующая альтернатива resttemplate, который в 5 версии спринга становится deprecated.
						Его не выпиливают, но развивать не будут. По факту часто все еще используется resttemplate.
						По привычке, из-за простоты и из-за того, что куча java туториалов писалась именно с ним.
					</aside>
				</section>
				<section>
					<h2>Docker, Docker Compose, Docker Hub</h2>
					<pre><code class="docker" data-trim data-line-numbers="3-12|14-25|27-35">
						version: '3.8'
						services:
							gateway:
								build: gateway
								image: shareit-gateway
								container_name: shareit-gateway
								ports:
									- "8080:8080"
								depends_on:
									- server
								environment:
									- SHAREIT_SERVER_URL=http://server:9090

							server:
								build: server
								image: shareit-server
								container_name: shareit-server
								ports:
									- "9090:9090"
								depends_on:
									- db
								environment:
									- SPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/shareit
									- SPRING_DATASOURCE_USERNAME=shareit
									- SPRING_DATASOURCE_PASSWORD=shareit

							db:
								image: postgres:14-alpine
								container_name: shareit-db
								ports:
									- "6541:5432"
								environment:
									- POSTGRES_PASSWORD=shareit
									- POSTGRES_USER=shareit
									- POSTGRES_DB=shareit
					</code></pre>
					<aside class="notes">
						Docker — распространенная платформа контейнеризации программного кода.<br>
						Нужна, чтобы на программу не влияло окружение, в котором она развернута и наоборот.<br>
						Позволяет запустить любую программу на любом компьютере, не задумываясь об их совместимости.<br>
						<br>
						DockerHub — сайт, на котором можно разместить программы-контейнеры и использовать с него чужие.<br>
						Не используется в продуктовой разработке.<br>
						Никто не хочет делиться своими наработками, плюс злоумышленники могут попортить все.<br>
						<br>
						Docker compose — утилита, помогающая одновременно развернуть несколько контейнеров и настроить связи.<br>
						Также не используется в продуктовой. Для тестов локально ок.<br>
						<br>
						Давайте разберемся еще раз с общением контейнеров при использовании Docker compose.<br>
						Когда запускается compose создается виртуальная сеть с именем, соответствующим названию папки вашего проекта.<br>
						Внутри это сети контейнеры доступны друг другу по названию хостов, соответствующих именам контейнеров.<br>
						Снаружи по этим ссылкам доступа не будет.<br>
						Ключевое слово ports вытаскивает на порт локальной машины порт контейнера из этой сети.<br>
						Но внутри виртуальной сети контейнеры доступны друг другу именно по порту контейнера — это второй порт после двоеточия.<br>
						На слайде показан код compose из референсного решения. Давайте пройдемся по всем контейнерам.
					</aside>
				</section>
				<section>
					<h2>Консоль</h2>
					<ol>
						<li>Системное администрирование</li>
						<li>Bash ценится как допскилл</li>
						<li>Shell скрипты универсальны</li>
						<li>Текстовые файлы на изи</li>
						<li>Низкое потребление ресурсов</li>
						<li>Облака = CLI</li>
						<li>Печатать быстрее, чем кликать</li>
						<li>Гит лучше изучать в терминале</li>
					</ol>
					<aside class="notes">
						Я часто говорил про важность консоли и повторю свои тезисы еще раз.<br>
						Конечно некоторые из них — вкусовщина, так что воспринимайте их как мое скромное мнение.<br>
						Системное администрирование проще, а некоторые настройки можно поменять только в терминале.<br>
						Скриптовый язык программирования Bash ценится как допскилл, с ним проще найти работу и можно получить больше зп.<br>
						Shell скрипты помогут в любой работе в IT, не только java разработчику.<br>
						Упрощаются рутинные операции с тектовыми файлами — например, в gui будет очень сложно найти что-то в логе размером 5Гб.<br>
						Терминал потребляет гораздо меньше системных ресурсов и именно поэтому GUI отключен на серверах.<br>
						Облака часто используют для управления терминал.<br>
						Набирать команды часто быстрее, чем кликать в гуи — я работаю с гитом именно по этой причине.<br>
						Я уже показывал надстройку ohmyzsh, где есть сокращения основных гит команд до 2 символов.<br>
						Я уже несколько раз говорил и повторю еще раз, гит лучше изучать в терминале, <br>
						потому что GUI скрывают особенности его работы из-за чего можно составить неправильное впечатление.<br>
					</aside>
				</section>
				<section>
					<h2>ФП16 ShareIt add docker</h2>
					<ul>
						<li>Выносим валидацию в gateway</li>
						<li>Реализуем модули в pom</li>
						<li>Дорабатываем шаблон</li>
						<li>Проверяем через docker-compose</li>
					</ul>
					<aside class="notes">
						<a href="https://github.com/yandex-praktikum/java-shareit/tree/add-docker">шаблон многомодульного проекта для ТЗ</a>
						Забираем шаблон по ссылке, закидываем себе в проект и раскидываем исходники по соответствующим папкам.<br>
						Модульность вам понадобиться дальше, в дипломном проекте больше модулей и сложнее связи.<br>
					</aside>
				</section>
				<section>
					<h2>Ваши вопросы</h2>
					<ul>
						<li>Микросервисы и монолиты</li>
						<li>Sync and async</li>
						<li>Docker, compose, hub</li>
						<li>Консоль</li>
						<li>ФП16 add docker</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
