<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<link rel="stylesheet" href="practicum/css/custom.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>


		<div class="reveal">
			<div class="watermark">
				<img src="practicum/images/yandex.svg" height="38"/>
				<img src="practicum/images/practicum.svg" />
			</div>

			<div class="slides">
				<section class="qa1">
					<section>
						<div class="container">
							<div class="col">
								<br>
								<div class="qa"><h1>Q&A</h1></div>
							</div>
							<div class="col">
								<img src="practicum/images/photo.tiff" height="300" />
								<h5>Егор Ерохин</h5>
								наставник
							</div>
							<aside class="notes">
								<a href="https://practicum.yandex.ru/webinar-form/java-developer/">Заранее зарегистрировать вебинар</a>
								(erohinegor)
								<br><br>
								Нужно быть залогиненым под учеткой, которая используется в практикуме. Выбрать пункт "студент". Нажать отправить.
								<br><br>
								Поставить на запись
								<br><br>
								Привет Камеры Ждем остальных
								<br><br>
							</aside>
						</div>
						<div class="footer">
							<a href="#/1">2</a>
							<a href="#/2">3</a>
							<a href="#/3">4</a>
							<a href="#/4">5</a>
							<a href="#/5">6</a>
							<a href="#/6">7</a>
							<a href="#/7">8</a>
							<a href="#/8">9</a>
							<a href="#/9">10</a>
							<a href="#/10">11</a>
							<a href="#/11">12</a>
							<a href="#/12">13</a>
							<a href="#/13">14</a>
							<a href="#/14">15</a>
							<a href="#/15">16</a>
							<a href="#/16">17</a>
							<a href="#/17">18</a>
							<a href="#/18">19</a>
						</div>
					</section>
				</section>
				<section class="qa2">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 2</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa3">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 3</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa4">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 4</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa5">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 5</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa6">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 6</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa7">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 7</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa8">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 8</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa9">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 9</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa10">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 10</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa11">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 11</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa12">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 12</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa13">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 13</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa14">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 14</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
					<section>
						<h2 data-id="code-title">Hibernate ORM</h2>
						<ul>
							<li>Object–relational mapping</li>
							<li>DTO pattern</li>
							<li>Транзакции</li>
							<li>Репозитории</li>
						</ul>
						<pre data-id="code-animation"><code class="hljs java" data-trim data-line-numbers>
							@Service
							public class ServiceTest {

								@Transactional
								public void test1() {
									test2();
								}

								@Transactional(propagation = Propagation.REQUIRES_NEW)
								public void test2() {
								}
							｝
						</code></pre>
						<aside class="notes">
							Мы наконец-то дошли до автоматизации запросов к базе и познакомились с Hibernate. ORM забирает у программиста часть ответственности за запросы к базе. Это уменьшает количество ошибок и позволяет менять СХД в случае необходимости.

							Также, вы рассмотрели паттерн DTO — отделяет сущности ORM и интерфейс сервиса, потому что в общем случае это разные вещи.

							Когда вы пишете приложение, может показаться логичным возвращать ровно то, что лежит в БД — то есть Entity.

							Но это ошибка — в современном гибком мире вы точно будете менять и БД и интерфейс сервиса, тогда почувствуете боль. Лучше сразу уменьшить связность и отделить интерфейс сервиса от сущности.

							Для маппинга есть удобные фреймворки, например mapstruct — вы пишете интерфейс маппера что-куда замапить, а фреймворк генерирует качественный код с проверками.

							Еще в этом модуле вы начали знакомиться с транзакциями, это довольно сложный концепт, который обеспечивает целостность данных в БД.  Хотел расскать о важной особенности аннотации @Transactional — на скрине сервис с двумя методами, помеченными этой аннотацией. Как вы думаете, сколько транзакций будет создано при вызове метода test1? — одна, потому что код управляющий транзакциями выполняется только при вызове метода снаружи объекта, на самом деле сервис оборачивается в прокси-объект

							Еще про транзакции — бывает, что при работе двух человек с БД один делает в ней изменения, а второй их не видит — это чаще всего связано с настройками клиента, выключен автокоммит. Несколько раз сталкивался с этим.

							Вообще как вы поняли — когда нужно использовать транзакции?

							При использовании JPQL десять раз подумайте, нет ли возможности обойтись без него.

							Запросы в коде на мой взгляд существенно усложняют его когнитивную сложность — вам приходится держать в голове не только ООП взаимодействие на JAVA, но и декларативный код запроса, который к тому же отличается от SQL.

							Один раз напишете запрос — придется его поддерживать и расширять. Очнетесь, когда он будет динамически составляться и содержать сотню строчек.

							В теории есть такой Момент:
							Доступно два вида сохранения. Первый — строковый вид EnumType.STRING. Он сохранит в базу строку, полученную в результате вызова метода enum-класса state.name(). Второй — целочисленный вид EnumType.ORDINAL. Он сохранит порядковый номер элемента перечисления — его также можно получить через вызов метода state.ordinal().  Какой вам больше нравится?  https://vladmihalcea.com/the-best-way-to-map-a-onetomany-association-with-jpa-and-hibernate/ https://habr.com/ru/articles/532000/ https://habr.com/ru/post/347752/
						</aside>
					</section>
					<section>
						<h4>Можно ли сделать запросный метод для выражения?</h4>
						<h2>((A and B) or (C and D)) and E</h2>
						<aside class="notes">
							В теории написано, что нельзя создать запросный метод на сложное выражение. Можно ли создать на такое?
							<br><br>
							Ответ: Можно — достаточно раскрыть скобки по правилам логических выражений.
						</aside>
					</section>
					<section>
						<h2 data-id="code-title">ACID</h2>
						<ul>
							<li>Atomicity — атомарность</li>
							<li>Consistency — согласованность</li>
							<li>Isolation — изоляция</li>
							<li>Durability — устойчивость</li>
						</ul>
						<aside class="notes">
							Акроним — набор требований к транзакционной системе, обеспечивающий надежную и предсказуемую работу.
							<br><br>
							Бывает на собеседованиях.
							<br><br>
							Давайте вместе вспомним, кто расскажет?
							<br><br>
							A — all or nothing, комплексная транзакция либо выполняется полностью либо никак. Важно — система должна гарантировать атомарность в любых ситуациях — при сетевых проблемах, ошибках программы, отказе железа и тп
							<br><br>
							C — корректно написанная транзакция сохраняет согласованность данных в БД. То есть все правила и ограничения данных в таблице будут сохранены.
							<br><br>
							I — параллельные транзакции не должны влиять друг на друга.
							<br><br>
							D — если транзакция завершилась и пользователю было возвращено ОК, то любые проблемы системы не могут на нее повлиять. Обычно значит, что результат записан в отказоустойчивой СХД.
						</aside>
					</section>
					<section>
						<h2>Проблема N+1</h2>
						<blockquote>
							&ldquo;The Hibernate recommendation is to statically
							<span class="fragment highlight-blue">mark all associations lazy</span> and to use
							dynamic fetching strategies for eagerness. This is unfortunately at odds with the JPA
							specification which defines that all one-to-one and many-to-one associations should be eagerly
							fetched by default. Hibernate, as a JPA provider, honors that default.
							&rdquo;
						</blockquote>
					</section>
					<section>
						<h2>Double brace initialisation</h2>
						<pre data-id="code-animation"><code class="hljs java" data-trim data-line-numbers>
							<script type="text/template">
							HashMap<String, String> map = new HashMap<>(){{
								put("1", "ONE");
								put("2", "TWO");
								put("3", "THREE");
							}};

							// анонимный внутренний класс
							HashMap<String, String> map1 = new HashMap<>(){

								{ // блок инициализации
									put("1", "ONE");
									put("2", "TWO");
									put("3", "THREE");
								}
							};
							</script>
						</code></pre>
					</section>
					<section>
						<h2>ФП14 ShareIt bookings</h2>
						<ul>
							<li>Добавить PostgreSQL</li>
							<li>Переход на JPA</li>
							<li>Booking — функция бронирования</li>
							<li>Даты бронирования</li>
							<li>Отзывы</li>
						</ul>
					</section>
					<section>
						<h2>Ваши вопросы</h2>
						<ul>
							<li>ORM</li>
							<li>DTO pattern</li>
							<li>Транзакции</li>
							<li>Репозитории</li>
							<li>ACID</li>
							<li>N+1</li>
							<li>Double brace</li>
							<li>ФП14</li>
						</ul>
					</section>
				</section>
				<section class="qa15">
					<section>
						<div class="container">
							<div class="col">
								<br><br>
								<h2>Q&A</h2>
								<h2>Спринт 15</h2>
							</div>
							<div class="col">
								<img src="practicum/images/photo.tiff" height="300" />
								<h5>Егор Ерохин</h5>
								<h8>Наставник</h8>
							</div>
						</div>
						<a href="#/0" class="footer">в начало</a>
						<aside class="notes">
							Mock и интеграционное тестирование<br>
							Маппинг объектов<br>
							Контейнеры<br>
							Оркестрация<br>
							ФП15
							<br><br>
							https://leetcode.com/problems/take-gifts-from-the-richest-pile/
							for (int i = 0; i < k; i++) {
							Arrays.sort(gifts);
							gifts[gifts.length - 1] = (int) Math.sqrt((double) gifts[gifts.length - 1]);
							}
							long s = 0;
							for (int gift : gifts) {
							s += gift;
							}
							return s;

							https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/description/

							public int findMaxK(int[] nums) {
							int res = -1;
							Set<Integer> set = new HashSet<>();
							for (int num : nums) {
							if (set.contains(-num)) {
							res = Math.max(res, Math.abs(num));
							}
							set.add(num);
							}
							return res;
							}
						</aside>
					</section>
					<section>
						<h2>Mock и Int тестирование</h2>
						<img src="practicum/images/15/mock-int.png">
						<aside class="notes">
							Вы познакомились с приемами написания юнит тестов через Моки или заглушки.
							Юнитом в юнит тестировании обычно называют класс приложения, соответственно в юнит тесте
							присутствует только его инстанс, а зависимости заменяются на заглушки и их поведение эмулируется.
							<br><br>
							Раньше для этого использовали разработку через интерфейсы — вместо боевой реализации в
							интерфейсное поле вставляли тестовую.
							Сейчас все гораздо проще — Mockito умеет замещать поведение у любого имеющегося класса.
							<br><br>
							Вам также показали, как писать интеграционные тесты, которые проверяют взаимодействие классов
							между собой и с внешним окружением
							<br><br>
							Юнит тесты обычно называют UserTest а интеграционные UserIntegrationTest
							<br><br>
							BDD — тесты приложения в целом
							<br><br>
							Обычно приложение имеет интерфейс, где пользователь нажимает кнопки и отправляет запросы в наше API
							<br><br>
							Есть разные инструменты, которые позволяют автоматизировать работу пользователя в браузере и
							прогонять в параллель большое количество тестов довольно быстро
							<br><br>
							Это полная программная эмуляция движка браузера с рендерингом, которая в случае появления
							ошибок может дампить содержимое консоли браузера и делать скрины страницы
							<br><br>
							Часто BDD пишут либо фронты либо Q&A инженеры
							<br><br>
							Стоит отметить, что BDD это behaviour driven dev — разработка через поведение. Это расширение
							TDD — разработки через тестирование.BDD как и TDD включает в себя не только практики
							разработки и инженерные, но и задачи аналитиков, менеджеров, а также привелечение бизнес заказчиков
						</aside>
					</section>
					<section>
						<h4>Где маппить DTO в Entity — в контроллерах или в сервисах?</h4>
						<div class="r-stack">
							<img class="fragment" src="practicum/images/15/dto-mapping.png">
							<img class="fragment" src="practicum/images/15/holy-war.tiff">
						</div>
						<aside class="notes">
							Есть два подхода — когда в сервисах работают с сущностями и маппинг происходит в контроллере
							<br><br>
							И когда сервисы принимают и возвращают DTO и маппинг происходит внутри них
							<br><br>
							Маппинг в сервисах, если смотреть на DTO — передает данные между слоями приложения
							<br><br>
							Натурально ограничивает изоляцию бизнес логики в сервисе — логика лежит между маппингом dto
							запроса в сущности и результатов в dto ответа. Если прямой и обратный маппинг в методе сервиса,
							то и все остальное там же.
							<br><br>
							Помогает избежать ошибок lazy сущностей вне транзакции — если такая сущность попадет в
							контроллер, будет ошибка could not initialize proxy - no Session
							<br><br>
							Изолирует домен сущностей бизнес логики от слоя контроллеров
							<br><br>
							Если у приложения будут другие интерфейсы — не только веб контроллеры, то логично маппинг оставить в одном месте — в сервисе
							<br><br>
							Маппинг в контроллере, если смотреть на DTO как на классы, отвечающие за внешнее взаимодействие
							<br><br>
							Мартин Фаулер, популярный лом в разработке, в своих статьях за этот вариант
							<br><br>
							Изолирует сервисный слой от особенностей внешнего взаимодействия
							<br><br>
							Облегчается бизнес логика, она содержит именно бизес код, тогда как преобразование это инженерный оверхед
							<br><br>
							Допустимы оба варианта, но конечно лучше придерживаться одного
							<br><br>
							Смотрите на окружение и делайте как принято
							<br><br>
							Еще один вопрос — Мапперы через статик методы или через компоненты спринга, ревьюеры просили исправить и одно и другое)
						</aside>
					</section>
					<section>
						<h2>Контейнеры и оркестрация K8s</h2>
						<img src="practicum/images/15/kubernetes.png">
						<aside class="notes">
							15 лет назад делали монолиты и выкладывали на сервера руками
							<br><br>
							Потом придумали разбивать приложение на микросервисы — это увеличивает изоляцию модулей приложения друг от друга
							<br><br>
							Docker — технология контейнеризации изолирует сервис от железа на котором он работает, что избавляет от ошибок, связанных с развертыванием в разных средах
							<br><br>
							Kubernetes — это автоматизация деплоя, масштабирования и управления контейнерами нашего микросервисного приложения
							<br><br>
							K8s — сокращенное название Kubernetes, часто можно встретить такие сокращения для длинных слов
							<br><br>
							Сейчас можно встретить разные варианты приложений, но стандартом является K8s
							<br><br>
							В 16 спринте вы переведете приложение на использование docker БД
						</aside>
					</section>
					<section>
						<h2>ФП15 ShareIt item requests</h2>
						<ul>
							<li>Запросы на добавление вещей</li>
							<li>Ответ на запрос вещи</li>
							<li>Пагинация через Pageable</li>
							<li>Тестирование</li>
						</ul>
						<aside class="notes">
							Разумная полнота тестов
							<br><br>
							Протечка слоя сущностей в DTO
							<br><br>
							Зачем одно и тоже гонять интеграционным и юнит?
							<br><br>
							Важно и то и то
							<br><br>
							Интеграционные тесты проверяют, что сервис корректно обрабатывает хорошие запросы и выдает ошибки на плохих
							<br><br>
							Юнит тесты проверяют то же самое, но для методов одного класса в отвязке от других классов
							<br><br>
							Happy path — правильную обработку корректных данных для классов еще можно перекрыть интеграционными тестами
							<br><br>
							Корректную обработку ошибочных входных данных — уже гораздо сложнее, — нужно в голове проводить реверс инжениринг приложения, чтобы понять, какие вводные данные в сервис должны быть, чтобы класс получил то, что не должен
						</aside>
					</section>
					<section>
						<h2>Ваши вопросы</h2>
						<ul>
							<li>Mock тестирование</li>
							<li>Маппинг объектов</li>
							<li>Контейнеры</li>
							<li>Оркестрация</li>
							<li>ФП15</li>
						</ul>
					</section>
				</section>
				<section class="qa16">
					<section>
						<h2>Спринт 16</h2>
						<ul>
							<li>Микросервисы</li>
							<li>Типы взаимодействия</li>
							<li>Docker (hub, compose)</li>
							<li>Работа на сервере</li>
						</ul>
						<br>
						<a href="#/0" class="footer">в начало</a>
						<aside class="notes">
							Рассмотрим некоторые паттерны микросервисов<br>
							Обсудим особенности синхронного и асинхронного взаимодействия<br>
							Разберем, как устроен Docker compose файл<br>
							Еще раз проговорим аргументы за терминал
							<br><br>
							<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">https://leetcode.com/problems/binary-tree-inorder-traversal/</a>
							Центрированный обход — сначала левая часть дерева, потом текущий узел, потом правая
							<pre><code class="java" data-trim>
								<script type="text/template">
									class Solution {
										public List<Integer> inorderTraversal(TreeNode root) {
											List<Integer> res = new ArrayList<>();
											inorder(root, res);
											return res;
										}

										public void inorder(TreeNode n, List<Integer> res) {
											if (n == null) return;
												inorder(n.left, res);
												res.add(n.val);
												inorder(n.right, res);
										}
									}
								</script>
							</code></pre>
							<a href="https://leetcode.com/problems/climbing-stairs/description/">https://leetcode.com/problems/climbing-stairs/description/</a>
							<pre><code class="java" data-trim>
							class Solution {
								// 1 - 1
								// 2 - 2
								public int climbStairs(int n) {
									if (n == 1) return 1;
									int[] dp = new int[n];
									dp[0] = 1;
									dp[1] = 2;
									for (int i = 2; i < n; i++) {
										dp[i] = dp[i - 1] + dp[i - 2];
									}
									return dp[n - 1];
								}
							}
							</code></pre>
						</aside>
					</section>
					<section>
						<h2>Микросервисы помогают</h2>
						<ul>
							<li>Добавлять новую функциональность</li>
							<li>Использовать разные технологии</li>
							<li>Переиспользовать код</li>
							<li>Масштабировать часть приложения</li>
							<li>Распределять задачи разработки</li>
						</ul>
						<aside class="notes">
							Как вы поняли, что такое микросервисы? (голосом или напечатать, обсудить)
							<br><br>
							Это архитектура, при которой бизнес логика разделяется между небольшими приложениями.
							<br><br>
							Чем микросервисы лучше монолита? (ответ из теории)
							<br><br>
							Их можно тестировать и развёртывать по отдельности.
							Это упрощает внесение изменений и добавление новой функциональности.
							<br><br>
							Микросервисы — это автономные компоненты, поэтому внутри одного приложения можно использовать
							разные фреймворки и даже языки программирования.
							<br><br>
							Небольшие сервисы можно переиспользовать другим командам — они реализуют конкретную функциональность,
							которую можно использовать в другом месте.
							<br><br>
							Можно масштабировать отдельную часть приложения, если какая-то функциональность сильно нагружена.
							<br><br>
							Микросервис проще изолировать от остального приложения и поручить отдельному разработчику.
							Следовательно, одновременно над одним кодом работает меньше человек, чем в случае с монолитом.
						</aside>
					</section>
<!-- Паттерны микросервисов это круто, но кажется, что лишнее на данном этапе -->
<!-- Пробую без них -->
<!--					<section>-->
<!--						<h2>Паттерны микросервисов</h2>-->
<!--						<ul>-->
<!--							<li>API Gateway</li>-->
<!--							<li>Service Registry/Discovery</li>-->
<!--							<li>Circuit Breaker</li>-->
<!--							<li>Event Sourcing</li>-->
<!--							<li>Strangler</li>-->
<!--						</ul>-->
<!--						<aside class="notes">-->
<!--							API Gateway: Этот паттерн предусматривает создание единой точки входа (API Gateway) для всех клиентских запросов. API Gateway принимает запросы, маршрутизирует их к соответствующим микросервисам и выполняет агрегацию данных при необходимости. Это позволяет упростить клиентскую логику, обеспечить единую точку управления и повысить безопасность системы.-->
<!--							<br><br>-->
<!--							Service Registry и Service Discovery: В микросервисной архитектуре, где сервисы могут динамически масштабироваться и развертываться, необходимо иметь механизмы для регистрации сервисов и их обнаружения. Service Registry представляет собой централизованный реестр, в котором сервисы регистрируют себя и свои адреса. Service Discovery позволяет клиентским сервисам динамически находить и взаимодействовать с другими сервисами.-->
<!--							<br><br>-->
<!--							Circuit Breaker: Этот паттерн предназначен для обработки сбоев во взаимодействии между микросервисами. Он предполагает использование специального компонента (Circuit Breaker), который отслеживает состояние и доступность сервисов. Если сервис становится недоступным или отвечает с ошибками, Circuit Breaker переключается в режим отказа и предотвращает дальнейшие неудачные запросы. Это позволяет предотвратить каскадные сбои и улучшить отказоустойчивость системы.-->
<!--							<br><br>-->
<!--							Паттерн Event Sourcing: Этот паттерн предлагает сохранять все изменения состояния системы в виде событий (events). Вместо сохранения текущего состояния, каждое действие, приводящее к изменению состояния, сохраняется как событие в журнале событий. Это позволяет восстановить состояние системы на любой момент времени и обеспечить аудит и отслеживаемость изменений.-->
<!--							<br><br>-->
<!--							Strangler: Если вы работаете в организации, которая находится на пути к модернизации приложений, то часто применяют шаблон проектирования Strangler. Паттерн Strangler выступает за создание надстройки фасада поверх вашего легаси и нового приложения. Функциональность API выносится из монолита постепенно. Монолит при этом каждую итерацию уменьшается в размере.-->
<!--						</aside>-->
<!--					</section>-->
					<section>
						<h2>Синхронное — асинхронное</h2>
						<img src="practicum/images/16/syncasync.tiff" height="400px">
						<img src="practicum/images/16/meme.tiff"height="400px">
						<aside class="notes">
							Кто расскажет чем отличается синхронное и асинхронное взаимодействие? (голосом или напечатать, обсудить)
							<br><br>
							При синхронном мы отправляем запрос и ждем ответа. При асинхронном кидаем в черный ящик запрос и продолжаем работу.
							Если нужен ответ — слушаем черный ящик.
							<br><br>

							Давайте рассмотрим синхронное — web и rest api.<br>
							Отправляем запрос в другой сервис, ждем и получаем ответ. Легче для реализации.<br>
							При этом раньше программа блокировалась, когда ждет ответ. Но сейчас есть неблокирующие реализации.<br>
							Балансировка при синхронном взаимодействии требует участия третьей стороны.<br>
							Часто для этого используют nginx, в Kubernetes это вообще скрывается от разработчика.<br>
							Но накладные расходы на балансировку остаются.<br>
							Доступно кэширование — например, при одинаковых запросах получение данных можно не выполнять логику,<br>
							а возвращать в течении определенного времени последний результат.<br>
							Отладка довольное сложная. Часто действия выглядят, как последовательные вызовы нескольких микросервисов.<br>
							Чтобы изучить проблему, нужно вытащить всю цепочку вызовов. Эта техника называется трейсинг.<br>
							Важный аспект — задать поведение при таймаутах. Потому что не все запросы могут выполниться.<br>
							Также, в HTTP часто в разных местах сети есть таймауты 60 сек, поэтому если запросы долгие, нужно перейти на асинхронное.<br>
							Строгого правила нет, но по моему опыту — до 1 сек хорошо, до 10 сек приемлемо, до 60 секунд на грани.<br>
							<br>

							Теперь рассмотрим асинхронное — шина обмена данными, например Kafka или rabbitmq.<br>
							Кидаем сообщение в шину, если надо слушаем очередь ответов.<br>
							Ниже связность между компонентами — каждый знает только про шину и ничего не знает о том, как происходит обработка.<br>
							Отладка проще — не нужно трассировать запросы, у каждого сервиса есть вход и выход.<br>
							Позволяет обработать сообщения заново, если что-то пошло не так — часто они сохраняются на шине.<br>
							Проще скейлить — ставишь столько обработчиков, сколько нужно.<br>
							Можно отправлять сообщение на обработку разными сервисами — они читают одну очередь независимо.<br>
							Брокер сообщений становится внешней зависимостью и единой точкой отказа.
							<br><br>
							Важное про RestTemplate — еще несколько лет назад все рекомендовали переходить на WebClient.
							Это новая неблокирующая альтернатива resttemplate, который в 5 версии спринга становится deprecated.
							Его не выпиливают, но развивать не будут. По факту часто все еще используется resttemplate.
							По привычке, из-за простоты и из-за того, что куча java туториалов писалась именно с ним.
						</aside>
					</section>
					<section>
						<h2>Docker, Docker Compose, Docker Hub</h2>
						<pre><code class="docker" data-trim data-line-numbers="3-12|14-25|27-35">
							version: '3.8'
							services:
								gateway:
									build: gateway
									image: shareit-gateway
									container_name: shareit-gateway
									ports:
										- "8080:8080"
									depends_on:
										- server
									environment:
										- SHAREIT_SERVER_URL=http://server:9090

								server:
									build: server
									image: shareit-server
									container_name: shareit-server
									ports:
										- "9090:9090"
									depends_on:
										- db
									environment:
										- SPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/shareit
										- SPRING_DATASOURCE_USERNAME=shareit
										- SPRING_DATASOURCE_PASSWORD=shareit

								db:
									image: postgres:14-alpine
									container_name: shareit-db
									ports:
										- "6541:5432"
									environment:
										- POSTGRES_PASSWORD=shareit
										- POSTGRES_USER=shareit
										- POSTGRES_DB=shareit
						</code></pre>
						<aside class="notes">
							Docker — распространенная платформа контейнеризации программного кода.<br>
							Нужна, чтобы на программу не влияло окружение, в котором она развернута и наоборот.<br>
							Позволяет запустить любую программу на любом компьютере, не задумываясь об их совместимости.<br>
							<br>
							DockerHub — сайт, на котором можно разместить программы-контейнеры и использовать с него чужие.<br>
							Не используется в продуктовой разработке.<br>
							Никто не хочет делиться своими наработками, плюс злоумышленники могут попортить все.<br>
							<br>
							Docker compose — утилита, помогающая одновременно развернуть несколько контейнеров и настроить связи.<br>
							Также не используется в продуктовой. Для тестов локально ок.<br>
							<br>
							Давайте разберемся еще раз с общением контейнеров при использовании Docker compose.<br>
							Когда запускается compose создается виртуальная сеть с именем, соответствующим названию папки вашего проекта.<br>
							Внутри это сети контейнеры доступны друг другу по названию хостов, соответствующих именам контейнеров.<br>
							Снаружи по этим ссылкам доступа не будет.<br>
							Ключевое слово ports вытаскивает на порт локальной машины порт контейнера из этой сети.<br>
							Но внутри виртуальной сети контейнеры доступны друг другу именно по порту контейнера — это второй порт после двоеточия.<br>
							На слайде показан код compose из референсного решения. Давайте пройдемся по всем контейнерам.
						</aside>
					</section>
					<section>
						<h2>Консоль</h2>
						<ol>
							<li>Системное администрирование</li>
							<li>Bash ценится как допскилл</li>
							<li>Shell скрипты универсальны</li>
							<li>Текстовые файлы на изи</li>
							<li>Низкое потребление ресурсов</li>
							<li>Облака = CLI</li>
							<li>Печатать быстрее, чем кликать</li>
							<li>Гит лучше изучать в терминале</li>
						</ol>
						<aside class="notes">
							Я часто говорил про важность консоли и повторю свои тезисы еще раз.<br>
							Конечно некоторые из них — вкусовщина, так что воспринимайте их как мое скромное мнение.<br>
							Системное администрирование проще, а некоторые настройки можно поменять только в терминале.<br>
							Скриптовый язык программирования Bash ценится как допскилл, с ним проще найти работу и можно получить больше зп.<br>
							Shell скрипты помогут в любой работе в IT, не только java разработчику.<br>
							Упрощаются рутинные операции с тектовыми файлами — например, в gui будет очень сложно найти что-то в логе размером 5Гб.<br>
							Терминал потребляет гораздо меньше системных ресурсов и именно поэтому GUI отключен на серверах.<br>
							Облака часто используют для управления терминал.<br>
							Набирать команды часто быстрее, чем кликать в гуи — я работаю с гитом именно по этой причине.<br>
							Я уже показывал надстройку ohmyzsh, где есть сокращения основных гит команд до 2 символов.<br>
							Я уже несколько раз говорил и повторю еще раз, гит лучше изучать в терминале, <br>
							потому что GUI скрывают особенности его работы из-за чего можно составить неправильное впечатление.<br>
						</aside>
					</section>
					<section>
						<h2>ФП16 ShareIt add docker</h2>
						<ul>
							<li>Выносим валидацию в gateway</li>
							<li>Реализуем модули в pom</li>
							<li>Дорабатываем шаблон</li>
							<li>Проверяем через docker-compose</li>
						</ul>
						<aside class="notes">
							<a href="https://github.com/yandex-praktikum/java-shareit/tree/add-docker">шаблон многомодульного проекта для ТЗ</a>
							Забираем шаблон по ссылке, закидываем себе в проект и раскидываем исходники по соответствующим папкам.<br>
							Модульность вам понадобиться дальше, в дипломном проекте больше модулей и сложнее связи.<br>
						</aside>
					</section>
					<section>
						<h2>Ваши вопросы</h2>
						<ul>
							<li>Микросервисы и монолиты</li>
							<li>Sync and async</li>
							<li>Docker, compose, hub</li>
							<li>Консоль</li>
							<li>ФП16 add docker</li>
						</ul>
					</section>
				</section>
				<section class="qa17">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 17</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa18">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 18</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
				<section class="qa19">
					<section>
						<h2>Q&A</h2>
						<h2>Спринт 19</h2>
						<a href="#/0" class="footer">в начало</a>
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
